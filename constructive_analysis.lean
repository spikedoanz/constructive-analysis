/-
Sorry, Aristotle was unable to complete the task in time.
-/
/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
-/

import Mathlib

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

#check NonemptyInterval

/-
Definition 1.1.1 I is a rational interval means I = [r, s], where r and s are rational numbers and r <= s.
-/
structure RationalInterval where
  lo : ℚ
  hi : ℚ
  le : lo ≤ hi

#check Membership
#check HasSubset

#print Membership
#print HasSubset

/-
Definition 1.1.2 x ∈ [r, s] means that x is a rational number and r <= x <= s.
Definition 1.1.4 [r, s] ⊂ [u, v] means that u <= r and s <= v.
-/
def RationalInterval.mem (I : RationalInterval) (x : ℚ) : Prop := I.lo ≤ x ∧ x ≤ I.hi

def RationalInterval.subset (I J : RationalInterval) : Prop := J.lo ≤ I.lo ∧ I.hi ≤ J.hi

instance : Membership ℚ RationalInterval := ⟨RationalInterval.mem⟩

instance : HasSubset RationalInterval := ⟨RationalInterval.subset⟩

/-
Definition 1.1.8 (ADDITION OF INTERVALS) I + J is the interval [r + u, s + v]
-/
def RationalInterval.add (I J : RationalInterval) : RationalInterval where
  lo := I.lo + J.lo
  hi := I.hi + J.hi
  le := add_le_add I.le J.le

instance : Add RationalInterval := ⟨RationalInterval.add⟩

/-
Definition 1.1.9 (NEGATION OF INTERVALS) -I is the interval [-s, -r]
-/
def RationalInterval.neg (I : RationalInterval) : RationalInterval where
  lo := -I.hi
  hi := -I.lo
  le := neg_le_neg I.le

instance : Neg RationalInterval := ⟨RationalInterval.neg⟩

/-
Definition 1.1.13 (MULTIPLICATION OF INTERVALS) For I = [r, s] and J = [u, v], IJ = [min(ru, rv, su, sv), max(ru, rv, su, sv)].
-/
def RationalInterval.mul (I J : RationalInterval) : RationalInterval where
  lo := min (min (I.lo * J.lo) (I.lo * J.hi)) (min (I.hi * J.lo) (I.hi * J.hi))
  hi := max (max (I.lo * J.lo) (I.lo * J.hi)) (max (I.hi * J.lo) (I.hi * J.hi))
  le := by
    apply le_trans (min_le_left _ _)
    apply le_trans (min_le_left _ _)
    apply le_trans (le_max_left _ _)
    apply le_max_left

instance : Mul RationalInterval := ⟨RationalInterval.mul⟩

/-
Definition 1.1.10 (SUBTRACTION OF INTERVALS) J - I is the interval J + (-I) = [u - s, v - r]
-/
def RationalInterval.sub (I J : RationalInterval) : RationalInterval := I + (-J)

instance : Sub RationalInterval := ⟨RationalInterval.sub⟩

/-
Definition 1.1.11 (THE O INTERVAL) We will occasionally denote the interval [0, 0] simply by 0.
Definition 1.1.18 (STRICT INEQUALITY FOR INTERVALS) I < J (also written J > I) means that s < u.
Definition 1.1.22 (LENGTH) l(I) = s - r is the length of [r, s].
-/
instance : Zero RationalInterval := ⟨{ lo := 0, hi := 0, le := le_refl 0 }⟩

instance : One RationalInterval := ⟨{ lo := 1, hi := 1, le := le_refl 1 }⟩

instance : LT RationalInterval := ⟨fun I J => I.hi < J.lo⟩

def RationalInterval.length (I : RationalInterval) : ℚ := I.hi - I.lo

/-
Definition 1.1.31 (MAX AND MIN FOR INTERVALS) max(I, J) = [max(r, u), max(s, v)]; min(I, J) = [min(r, u), min(s, v)].
-/
def RationalInterval.max (I J : RationalInterval) : RationalInterval where
  lo := Max.max I.lo J.lo
  hi := Max.max I.hi J.hi
  le := max_le_max I.le J.le

def RationalInterval.min (I J : RationalInterval) : RationalInterval where
  lo := Min.min I.lo J.lo
  hi := Min.min I.hi J.hi
  le := min_le_min I.le J.le

instance : Max RationalInterval := ⟨RationalInterval.max⟩
instance : Min RationalInterval := ⟨RationalInterval.min⟩

#check abs

#check (max 1 2 : ℚ)
#check (abs 1 : ℚ)

/-
PROPOSITION 1.1.23 l(I + J) = l(I) + l(J)
-/
theorem RationalInterval.length_add (I J : RationalInterval) : (I + J).length = I.length + J.length := by
  unfold RationalInterval.length;
  exact sub_eq_of_eq_add <| by linarith! [ I.le, J.le, show ( I + J ).hi = I.hi + J.hi from rfl, show ( I + J ).lo = I.lo + J.lo from rfl ] ;

/-
PROPOSITION 1.1.24 l(-I) = l(I)
-/
theorem RationalInterval.length_neg (I : RationalInterval) : (-I).length = I.length := by
  -- By definition of negation, we have (-I).lo = -I.hi and (-I).hi = -I.lo.
  simp [RationalInterval.length, RationalInterval.neg];
  -- By definition of negation, we have (-I).hi = -I.lo and (-I).lo = -I.hi.
  have h_neg : (-I).hi = -I.lo ∧ (-I).lo = -I.hi := by
    exact ⟨ rfl, rfl ⟩;
  bound

/-
Definition 1.1.28 (ABSOLUTE VALUE FOR INTERVALS) |I| = I if I > 0, -I if I < 0, [0, max(-r, s)] otherwise.
-/
def RationalInterval.abs (I : RationalInterval) : RationalInterval :=
  if 0 < I.lo then I
  else if I.hi < 0 then -I
  else { lo := 0, hi := if -I.lo < I.hi then I.hi else -I.lo, le := by
          split_ifs <;> linarith [ I.le ] }

#check Inv
#check Div

/-
Definition 1.1.20 (RECIPROCAL) For I > 0 or I < 0, 1/I is the interval [1/s, 1/r]
Definition 1.1.13 (DIVISION) I/J = I * (1/J).
-/
def RationalInterval.inv (I : RationalInterval) : RationalInterval :=
  if h : 0 < I.lo ∨ I.hi < 0 then
    { lo := 1 / I.hi,
      hi := 1 / I.lo,
      le := by
        -- Let's consider the two cases from the hypothesis h.
        cases h <;> aesop;
        · exact inv_anti₀ h I.le;
        · rw [ inv_le_inv_of_neg ] <;> linarith [ I.le ]
    }
  else
    0

instance : Inv RationalInterval := ⟨RationalInterval.inv⟩

def RationalInterval.div (I J : RationalInterval) : RationalInterval := I * J⁻¹

instance : Div RationalInterval := ⟨RationalInterval.div⟩

/-
PROPOSITION 1.1.25 Suppose I = [r, s] and c is a any number such that 0 < c <= r: then l(1/I) <= l(I)/c^2
-/
theorem RationalInterval.length_inv (I : RationalInterval) (c : ℚ) (hc : 0 < c) (h : c ≤ I.lo) :
  (I⁻¹).length ≤ I.length / c^2 := by
    -- Since $c \leq r$, we have $1/s \leq 1/c$ and $1/r \leq 1/c$. Therefore, $1/r - 1/s \leq 1/c - 1/s$.
    have h_inv_le : (I⁻¹).length ≤ (1 / I.lo - 1 / I.hi) := by
      -- Since $I$ is positive, the inverse of $I$ is $[1/I.hi, 1/I.lo]$, and the length is $1/I.lo - 1/I.hi$.
      have h_inv_pos : 0 < I.lo := by
        -- Since $c$ is positive and $c \leq I.lo$, it follows that $I.lo$ is also positive.
        exact lt_of_lt_of_le hc h;
      -- Since $I$ is positive, the inverse of $I$ is $[1/I.hi, 1/I.lo]$, and the length is $1/I.lo - 1/I.hi$. Therefore, the inequality holds as an equality.
      have h_inv_pos : I⁻¹ = ⟨1 / I.hi, 1 / I.lo, by
        exact one_div_le_one_div_of_le ( by linarith ) ( by linarith [ I.le ] )⟩ := by
        exact if_pos ( Or.inl h_inv_pos )
      generalize_proofs at *;
      exact h_inv_pos ▸ by norm_num [ RationalInterval.length ] ;
    -- Since $1/s \leq 1/c$ and $1/r \leq 1/c$, we have $1/r - 1/s \leq 1/c - 1/s$. Therefore, $1/r - 1/s \leq (s - r) / (c^2)$.
    have h_inv_le_div : (1 / I.lo - 1 / I.hi) ≤ (I.hi - I.lo) / (c^2) := by
      -- Combine the fractions on the left side: $1/I.lo - 1/I.hi = (I.hi - I.lo) / (I.lo * I.hi)$.
      have h_combined : 1 / I.lo - 1 / I.hi = (I.hi - I.lo) / (I.lo * I.hi) := by
        rw [ div_sub_div ] <;> ring <;> nlinarith [ I.le, I.hi, I.lo ];
      rw [ h_combined ];
      bound;
      · exact I.le;
      · nlinarith [ I.le ];
    exact h_inv_le.trans h_inv_le_div

/-
PROPOSITION 1.1.26 Suppose I ⊂ (-∞, d) where d < 0. Then l(1/I) <= l(I)/d^2
-/
theorem RationalInterval.length_inv_neg (I : RationalInterval) (d : ℚ) (hd : d < 0) (h : I.hi ≤ d) :
  (I⁻¹).length ≤ I.length / d^2 := by
    -- Since $I.hi \leq d$ and $d < 0$, we have $I.hi < 0$. Therefore, $I.lo \leq I.hi < 0$, which implies $I.lo < 0$.
    have h_neg : I.lo < 0 ∧ I.hi < 0 := by
      constructor <;> linarith [ I.le ];
    have h_inv_length : (I⁻¹).length = (I.length) / (I.lo * I.hi) := by
      -- By definition of inverse, we have $I⁻¹ = [1/I.hi, 1/I.lo]$.
      have h_inv_def : I⁻¹ = ⟨1 / I.hi, 1 / I.lo, by
        rw [ div_le_iff_of_neg ] <;> nlinarith [ I.le, div_mul_cancel₀ 1 ( ne_of_lt h_neg.1 ), div_mul_cancel₀ 1 ( ne_of_lt h_neg.2 ) ]⟩ := by
        exact if_pos ( Or.inr h_neg.2 )
      generalize_proofs at *;
      unfold RationalInterval.length at * ; aesop;
      rw [ inv_sub_inv ] <;> ring <;> linarith;
    -- Since $I.hi \leq d$ and both are negative, their product $I.lo * I.hi$ is greater than or equal to $d^2$.
    have h_prod_ge_d_sq : I.lo * I.hi ≥ d^2 := by
      nlinarith [ I.le ];
    rw [ h_inv_length ];
    exact div_le_div_of_nonneg_left ( sub_nonneg.mpr I.le ) ( sq_pos_of_neg hd ) h_prod_ge_d_sq

/-
PROPOSITION 1.1.29 |I| is the smallest interval containing all |x| for x ∈ I
-/
theorem RationalInterval.abs_mem (I : RationalInterval) (x : ℚ) (hx : x ∈ I) : |x| ∈ I.abs := by
  unfold RationalInterval.abs;
  aesop;
  · cases abs_cases x <;> constructor <;> linarith [ hx.1, hx.2, I.le ];
  · -- Since $x \in I$ and $I.hi < 0$, we have $x < 0$. Therefore, $|x| = -x$.
    have hx_neg : x < 0 := by
      linarith [ hx.2 ];
    -- Since $x \in I$ and $I.hi < 0$, we have $I.lo \leq x \leq I.hi$. Multiplying by $-1$ reverses the inequalities: $-I.hi \leq -x \leq -I.lo$.
    have h_neg : -I.hi ≤ -x ∧ -x ≤ -I.lo := by
      constructor <;> linarith [ hx.1, hx.2 ];
    constructor <;> cases abs_cases x <;> linarith [ abs_of_neg hx_neg, I.le, show ( -I ).lo = -I.hi from rfl, show ( -I ).hi = -I.lo from rfl ];
  · cases abs_cases x <;> constructor <;> linarith [ hx.1, hx.2 ];
  · cases abs_cases x <;> constructor <;> linarith [ hx.1, hx.2 ]

#check RationalInterval.abs
#print RationalInterval.abs

/-
PROPOSITION 1.1.30 l(|I|) <= l(I)
-/
theorem RationalInterval.length_abs (I : RationalInterval) : (I.abs).length ≤ I.length := by
  unfold RationalInterval.length; aesop;
  unfold RationalInterval.abs; aesop;
  linarith! [ I.le, show ( -I ).hi = -I.lo from rfl, show ( -I ).lo = -I.hi from rfl ]

/-
PROPOSITION 1.1.32 K < max(I, J) if and only if K < I or K < J
-/
theorem RationalInterval.lt_max_iff (I J K : RationalInterval) : K < max I J ↔ K < I ∨ K < J := by
  -- By definition of max, we know that K < max(I, J) if and only if K.hi < max(I.lo, J.lo).
  simp [RationalInterval.max];
  -- By definition of max, we know that K < max(I, J) if and only if K.hi < max(I.lo, J.lo).
  simp [LT.lt];
  cases max_choice I.lo J.lo <;> aesop;
  · -- Since $J.lo \leq I.lo$, if $K.hi < J.lo$, then $K.hi < I.lo$ by transitivity of inequalities.
    have h_trans : K.hi < J.lo → J.lo ≤ I.lo → K.hi < I.lo := by
      exact fun h₁ h₂ => lt_of_lt_of_le h₁ h₂;
    aesop;
  · exact lt_of_lt_of_le ( by simpa using a ) h

/-
PROPOSITION 1.1.32 K > max(I, J) if and only if K > I and K > J
-/
theorem RationalInterval.max_lt_iff (I J K : RationalInterval) : max I J < K ↔ I < K ∧ J < K := by
  -- By definition of max, we know that max(I, J) < K if and only if both I < K and J < K.
  simp [RationalInterval.max];
  -- By definition of max, we know that max(I, J) < K if and only if both I < K and J < K. This follows from the fact that the maximum of two numbers is less than K if and only if both numbers are less than K.
  apply Iff.intro;
  · -- If the maximum of I and J is less than K, then both I and J must be less than K.
    intro h_max_lt_K
    have h_I_lt_K : I < K := by
      cases max_cases I.hi J.hi <;> cases max_cases I.lo J.lo <;> aesop;
      · exact lt_of_le_of_lt ( by exact show I.hi ≤ J.hi from h ) h_max_lt_K;
      · exact lt_of_le_of_lt ( le_of_lt right ) h_max_lt_K
    have h_J_lt_K : J < K := by
      cases max_cases I.hi J.hi <;> cases max_cases I.lo J.lo <;> aesop;
      · exact lt_of_le_of_lt h h_I_lt_K;
      · exact lt_of_le_of_lt right h_I_lt_K
    exact ⟨h_I_lt_K, h_J_lt_K⟩;
  · cases max_cases I.lo J.lo <;> cases max_cases I.hi J.hi <;> aesop

/-
PROPOSITION 1.1.33 The interval max(I, J) is the smallest interval containing all max(x, y) for x ∈ I and y ∈ J. (Part 1: existence)
-/
theorem RationalInterval.max_mem (I J : RationalInterval) (x y : ℚ) (hx : x ∈ I) (hy : y ∈ J) : Max.max x y ∈ max I J := by
  cases max_cases x y <;> cases max_cases I.lo J.lo <;> cases max_cases I.hi J.hi <;> constructor <;> linarith! [ hx.1, hx.2, hy.1, hy.2 ]

#check RationalInterval.max_mem

/-
Definition 1.2.1 We say the intervals I and J intersect, or meet, if there is a rational number x which belongs to both I and J.
Proposition 1.2.2 I = [r, s] and J = [u, v] intersect <=> r <= v and u <= s.
-/
def RationalInterval.intersects (I J : RationalInterval) : Prop :=
  ∃ x : ℚ, x ∈ I ∧ x ∈ J

theorem RationalInterval.intersects_iff (I J : RationalInterval) :
  I.intersects J ↔ I.lo ≤ J.hi ∧ J.lo ≤ I.hi := by
    bound;
    · cases a ; aesop;
      linarith [ left.1, left.2, right.1, right.2 ];
    · cases a ; aesop;
      linarith [ left.1, left.2, right.1, right.2 ];
    · -- Since $I.lo \leq J.hi$ and $J.lo \leq I.hi$, the intervals $I$ and $J$ overlap.
      have h_overlap : ∃ x, I.lo ≤ x ∧ x ≤ I.hi ∧ J.lo ≤ x ∧ x ≤ J.hi := by
        exact ⟨ Max.max I.lo J.lo, le_max_left _ _, by cases max_cases I.lo J.lo <;> linarith [ I.le ], le_max_right _ _, by cases max_cases I.lo J.lo <;> linarith [ J.le ] ⟩;
      -- Apply the definition of intersects using the x from h_overlap.
      apply Exists.intro (h_overlap.choose);
      exact ⟨ ⟨ h_overlap.choose_spec.1, h_overlap.choose_spec.2.1 ⟩, ⟨ h_overlap.choose_spec.2.2.1, h_overlap.choose_spec.2.2.2 ⟩ ⟩

/-
NOTATION 1.2.3 If I and J intersect, their intersection is an interval given by I ∩ J = [max(r, u), min(s, v)].
-/
def RationalInterval.inter (I J : RationalInterval) (h : I.intersects J) : RationalInterval where
  lo := Max.max I.lo J.lo
  hi := Min.min I.hi J.hi
  le := by
    rw [RationalInterval.intersects_iff] at h
    apply le_min
    · apply max_le
      · exact I.le
      · exact h.2
    · apply max_le
      · exact h.1
      · exact J.le

#check RationalInterval.abs

/-
PROPOSITION 1.2.2 I = [r, s] and J = [u, v] intersect <=> r <= v and u <= s.
NOTATION 1.2.3 If I and J intersect, their intersection is an interval given by I ∩ J = [max(r, u), min(s, v)].
Exercise 9. Assuming that I and J intersect, prove that I ∩ J is the smallest interval which contains all x such that x ∈ I and x ∈ J.
-/
theorem RationalInterval.mem_inter (I J : RationalInterval) (h : I.intersects J) (x : ℚ) :
  x ∈ I.inter J h ↔ x ∈ I ∧ x ∈ J := by
    constructor <;> intro H;
    · cases H;
      unfold RationalInterval.inter at *;
      aesop;
      · exact ⟨ left, left_1 ⟩;
      · exact ⟨ right_1, right ⟩;
    · unfold RationalInterval.inter; aesop;
      exact ⟨ by cases max_cases I.lo J.lo <;> linarith [ left.1, left.2, right.1, right.2 ], by cases min_cases I.hi J.hi <;> linarith [ left.1, left.2, right.1, right.2 ] ⟩

/-
Proposition: I ⊆ J if and only if for all x, x ∈ I implies x ∈ J.
-/
theorem RationalInterval.subset_iff_mem (I J : RationalInterval) :
  I ⊆ J ↔ ∀ x : ℚ, x ∈ I → x ∈ J := by
  constructor
  · intro h x hx
    cases h
    cases hx
    constructor
    · linarith
    · linarith
  · intro h
    constructor
    · have : I.lo ∈ I := ⟨le_refl _, I.le⟩
      have : I.lo ∈ J := h I.lo this
      exact this.1
    · have : I.hi ∈ I := ⟨I.le, le_refl _⟩
      have : I.hi ∈ J := h I.hi this
      exact this.2

/-
Definition 1.2.8 F is a consistent family of intervals means that for every pair of intervals I and J in F, I and J intersect.
-/
def Consistent (F : Set RationalInterval) : Prop :=
  ∀ I ∈ F, ∀ J ∈ F, I.intersects J

def List.Consistent (L : List RationalInterval) : Prop :=
  ∀ I ∈ L, ∀ J ∈ L, I.intersects J

#check RationalInterval.inv
#synth Inv RationalInterval

/-
PROPOSITION 1.1.33 The interval max(I, J) is the smallest interval containing all max(x, y) for x ∈ I and y ∈ J. (Part 2: minimality)
-/
theorem RationalInterval.max_minimal (I J K : RationalInterval) (h : ∀ x ∈ I, ∀ y ∈ J, Max.max x y ∈ K) : max I J ⊆ K := by
  -- Take any element z in the max of I and J. By definition, z is either I.lo and I.hi, or J.lo and J.hi.
  have hz : ∀ z : ℚ, z ∈ I.max J → z ∈ K := by
    -- By definition of max, if z is in the max of I and J, then z is either in I or in J.
    intro z hz
    cases' hz with hzI hzJ;
    -- Since $z$ is between $I.lo$ and $J.hi$, and $K$ contains all maxima of elements from $I$ and $J$, then $z$ must be in $K$.
    by_cases hzI_J : z ≤ J.hi;
    · have hzJ_I : z ≥ J.lo := by
        exact le_trans ( by exact le_max_right _ _ ) hzI;
      convert h ( I.lo ) ( by constructor <;> linarith [ I.le ] ) ( z ) ( by constructor <;> linarith [ J.le ] ) using 1 ; aesop;
      exact le_trans ( le_max_left _ _ ) hzI;
    · unfold RationalInterval.max at *; aesop;
      convert h z ( by constructor <;> linarith ) J.hi ( by constructor <;> linarith [ J.le ] ) using 1 ; aesop;
      linarith;
  exact?

#check RationalInterval.max_minimal